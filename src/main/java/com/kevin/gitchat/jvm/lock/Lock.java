package com.kevin.gitchat.jvm.lock;

/**
 * Java锁的分类维度：
 * 1.共享角度: 多个线程是否可以共享一把锁？能：共享锁,不能:排他锁
 * 2.同一个线程在执行过程中是否可以获取同一把锁？能：可重入锁，不能：非可重入锁
 * 3.从资源的角度:线程在执行更新操作的时候，是否需要利用锁，锁住同步资源？需要：悲观锁，不需要：乐观锁
 * 4.多线程在竞争资源的时候，是否需要排队等待？需要：公平锁；不需要：非公平锁
 * 5.当线程尝试锁住同步资源，但是失败了，那么线程需要阻塞么？堵塞（线程从用户态进入内核态，等待资源释放由cpu唤醒），不阻塞：自旋（用户态），
 * 如果线程在自旋过程一直没有获取到同步资源，那么该线程最终还是会被堵塞，进入到内核态(自适应自旋)。
 * 6.多线程在竞争同步资源是过程区别？无锁：多线程会同时对资源进行修改，并且不会锁住资源，在这种情况下，某一时刻只会有一个线程对资源修改成功,
 * 其他线程失败，失败的线程会不断的进行重试（cas）；同一个线程在执行时，如果遇到同步资源，那么它会自动获取到这个同步资源，而不需要其他任何操作(偏向锁)。
 * 多个线程同时在尝试竞争锁资源，同一个时刻只会有一个线程获取到锁，那么其他没有获取到锁的线程会进行自旋等待锁的释放(轻量锁)；
 * 多个线程同时在尝试竞争锁资源,并且进行了自旋，但是经过了一段时间后，线程依然无法获取到锁资源，这个时候，没有获取到锁资源的线程将会进入到堵塞状态,等待cpu的唤醒。
 *
 *
 * 关于乐观锁和悲观锁的使用场景
 * 乐观锁: 适用于读操作比较多的场景，因为本身不加锁，所以使得操作的性能有着非常明显的提升
 * 悲观锁: 适用于写操作比较多的场景，因为首先需要对锁的资源进行加锁操作，所以完全可以保证写入操作的正确和健壮。
 *
 *
 * CAS（compare and swap）,比较和交换
 *
 * CAS 算法本质上涉及到三个数字：
 * 1. 需要进行读写的内存值V
 * 2. 需要进行比较的值A
 * 3. 需要进行写入的新值B
 *
 * 比较和更新是一个原子操作，它在cpu层面上是一个指令完成的。
 *
 *
 *
 *
 * @author wangyong
 */
public class Lock {

}
